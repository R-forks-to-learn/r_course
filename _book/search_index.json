[
["index.html", "Modern R for STATEC Preface What is R? What is Rstudio? Prerequisites What are packages?", " Modern R for STATEC Bruno Rodrigues 2017-10-11 Preface What is R? Read R’s official answer to this question here. To make it short: R is multi-paradigm (procedural, imperative, object-oriented and functional)1 programming language that focuses on applications in statistics. By statistics I mean any field that uses statistics such as official statistics, economics, finance, data science, etc. What is Rstudio? Rstudio is a modern IDE that makes writing R code easier. The first thing we are going to learn is how to use it. R and Rstudio are both open source: this means that the source code is freely available on the internet and contributions by anyone are welcome and integrated; provided they are meaningful and useful. Prerequisites R and Rstudio are the two main pieces of software that we are going to use. Both are already installed on your desktop computer. R is the programming language and Rstudio is a modern IDE for it. You can use R without Rstudio; but you cannot use Rstudio without R. If you wish to install R and Rstudio at home to follow the examples in this book you can do it as both pieces of software are available free of charge (for firms paid options for Rstudio exist). Installation is simple, but operating system dependent. To download and install R for Windows, follow this link. For macOS, follow this one. If you run a GNU+Linux distribution, you can install R using the system’s package manager. On Ubuntu, install r-base. For Rstudio, look for your operating system here. What are packages? There is one more step; we are going to install some packages. Packages are additional pieces of code that can be installed from within R with the following function: install.packages(). These packages extend R’s capabilities significantly, and are probably one of the main reasons R is so popular. As of October 2017, R has over 11000 packages. To install the packages we need, first open Rstudio and then copy and paste this line in the console: install.packages(c(&quot;tidyverse&quot;, &quot;checkpoint&quot;, &quot;eurostat&quot;, &quot;ggthemes&quot;, &quot;janitor&quot;, &quot;openxlsx&quot;, &quot;rio&quot;)) or go to the Packages pane and then click on Install: The author My name is Bruno Rodrigues and I work in the research department of STATEC. I program almost exclusively in R and have been teaching some R courses for a few years now (first started teaching for students at the Université of Strasbourg). These notes are an update of those I used at the time, plus a lot of things I’ve learned about R since I started working at STATEC. I also am writing another book that is more advanced than this one. In my free time I like cooking, boxing and blogging. You can follow me on twitter if you’d like! In this book we are going to focus on R’s functional programming capabilities↩ "],
["getting-to-know-rstudio.html", "Chapter 1 Getting to know Rstudio 1.1 Panes 1.2 Console 1.3 Scripts 1.4 Options 1.5 Keyboard shortcuts 1.6 Projects 1.7 History 1.8 Plots", " Chapter 1 Getting to know Rstudio 1.1 Panes Rstudio is divided into different panes. Each pane has a specific function. The gif below shows some of these panes: Take some time to look around what each pane shows you. Some panes are empty; for example the Plots pane or the Viewer pane. Plots shows you the plots you make. You can browse the plots and save them. We will see this in more detail in a later chapter. Viewer shows you previews of documents that you generate with R. More on this later. 1.2 Console The Console pane is where you can execute R code. Write the following in the console: 2 + 3 and you’ll get the answer, 5. However, do not write a lot of lines in the console. It is better write your code inside a script. 1.3 Scripts Look at the gif below: In this gif, we see the user creating a new R script. R scripts are simple text files that hold R code. Think of .do files in STATA or .c files for C. R scripts have the extension .r or .R. It is possible to create a lot of other files. We’ll take a look at R Markdown files later. 1.3.1 The help pane The Help pane allows you to consult documentation for functions or packages. The gif below shows how it works: you can also access help using the following syntax: ?lm. This will bring up the documentation for the function lm(). You can also type ??lm which will look for the string lm in every package. 1.3.2 The Environment pane The Environment pane shows every object created in the current section. It is especially useful if you have defined lists or have loaded data into R as it makes it easy to explore these more complex objects. 1.4 Options It is also possible to customize Rstudio’s look and feel: Take some time to go through the options. 1.5 Keyboard shortcuts It is a good idea to familiarize yourself with at least some keyboard shortcuts. This is more convenient than having to move the mouse around: If there is only one keyboard shortcut you need to know, it’s Ctrl-Enter that executes a line of code from your script. However, these other shortcuts are also worth knowing: CTRL-ALT-R: run entire script CTRL-ALT-UP or DOWN: make cursor taller or shorter, allowing you to edit multiple lines at the same time CTRL-F: Search and replace ALT-UP or DOWN: Move line up or down CTRL-SHIFT-C: Comment/uncomment line ALT-SHIFT-K: Bring up the list of keyboard shortcuts CTRL-SHIFT-M: Insert the pipe operator (%&gt;%, more on this later) CTRL-S: Save script This is just a few keyboard shortcuts that I personally find useful. However, I strongly advise you to learn and use whatever shortcuts are useful to you! 1.6 Projects One of the best features of Rstudio are projects. Creating a project is simple; the gif below shows how you can create a project and how you can switch between projects. Projects make a lot of things easier, such as managing paths. More on this in the chapter about reading data. Another useful feature of projects is that the scripts you open in project A will stay open even if you switch to another project B, and then switch back to the project A again. You can also use version control (with git) inside a project. Version control is very useful, but I won’t discuss it here. You can find a lot of resources online to get you started with git. 1.7 History The history pane saves all the previous lines you executed. You can then select these lines and send them back to the console or the script. 1.8 Plots All the plots you make during a session are visible in the Plots pane. From there, you can export them in different formats. The plots shown in the gif are made using basic R functions. Later, we will learn how to make nicer looking plots using the package ggplot2. "],
["packages.html", "Chapter 2 Packages", " Chapter 2 Packages You can think of packages as addons that extend R’s core functionality. You can browse all available package on CRAN. To make it easier to find what you might be interested in, you can also browes the CRAN Task Views. Each package has a landing page that summarises its dependencies, version number etc. For example, for the dplyr package: https://cran.r-project.org/web/packages/dplyr/index.html. Take a look at the Downloads section, and especially at the Reference Manual and Vignettes: Vignettes are valuable documents; inside vignettes, the purpose of the package is explained in plain English, usually with accompanying examples. The reference manuals list the available functions inside the packages. You can also find vignettes from within Rstudio: Go to the Packages pane and click on the package you’re interested in. Then you can consult the help for the functions that come with the package as well as the package’s vignettes. Once you installed a package, you have to load it before you can use it. To load packages you use the library() function: library(dplyr) library(janitor) # and so on... If you only need to use one single function once, you don’t need to load an entire package. You can write the following: dplyr::full_join(A, B) using the :: operator, you can access functions from packages without having to load the whole package beforehand. It is possible and easy to create your own packages. This is useful if you have to write a lot of functions that you use daily. This is outside the scope of this book, but if you’re interested you can read this other one I wrote. "],
["data-types-and-objects.html", "Chapter 3 Data types and objects 3.1 The numeric class 3.2 The character class 3.3 Vectors and matrices 3.4 The logical class 3.5 The list class 3.6 Exercises", " Chapter 3 Data types and objects R use a variety of data types. You already know most of them, actually! Integers (), floating point numbers, or floats (), matrices, etc, are all objects you already use on a daily basis. But R has a lot of other data types (that you can find in a lot of other programming languages) that you need to become familiar with. But first, we need to learn how to assign a variable. This can be done in two ways: a = 3 or a = 3 there is almost no difference between these two approaches. Out of habit, I use =, but you can use = if you wish. 3.1 The numeric class To define single numbers, you can do the following: a = 3 The class() function allows you to check the class of an object: class(a) ## [1] &quot;numeric&quot; Decimals are defined with the character `.}: a = 3.14 3.2 The character class Use &quot; &quot; to define characters (called strings in other programming languages): a = &quot;this is a string&quot; class(a) ## [1] &quot;character&quot; 3.3 Vectors and matrices You can create a vector in different ways. But first of all, it is important to understand that a vector in most programming languages is nothing more than a list of things. These things can be numbers (either integers or floats), strings, or even other vectors. The same applies for matrices. 3.3.1 The c() function matrix_a very important function that allows you to build a vector is c(): a = c(1,2,3,4,5) This creates a vector with elements 1, 2, 3, 4, 5. If you check its class: class(a) ## [1] &quot;numeric&quot; This can be confusing: you where probably expecting a to be of class or something similar. This is not the case if you use c() to create the vector, because c() doesn’t build a vector in the mathematical sense, but rather a list with numbers. Checking its dimension: dim(a) ## NULL matrix_a list doesn’t have a dimension, that’s why the dim() command returns NULL. If you want to create a true vector, you need to use cbind() or rbind(). 3.3.2 cbind() and rbind() You can create a true vector with cbind(): a = cbind(1,2,3,4,5) Check its class now: class(a) ## [1] &quot;matrix&quot; This is exactly what we expected. Let’s check its dimension: dim(a) ## [1] 1 5 This returns the dimension of a using the LICO notation (number of LInes first, the number of COlumns). It is also possible to bind vectors together to create a matrix. b = cbind(6,7,8,9,10) Now let’s put vector a and b into a matrix called matrix_c using rbind(). rbind() functions the same way as cbind() but glues the vectors together by rows and not by columns. matrix_c = rbind(a,b) print(matrix_c) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 3.3.3 The matrix class R also has support for matrices. For example, you can create a matrix of dimension (5,5) filled with 0’s with the matrix() function: matrix_a = matrix(0, nrow = 5, ncol = 5) If you want to create the following matrix: \\[ B = \\left( \\begin{array}{ccc} 2 &amp; 4 &amp; 3 \\\\ 1 &amp; 5 &amp; 7 \\end{array} \\right) \\] you would do it like this: B = matrix(c(2, 4, 3, 1, 5, 7), nrow = 2, byrow = TRUE) The option byrow = TRUE means that the rows of the matrix will be filled first. You can access individual elements of matrix_A like so: matrix_a[2, 3] ## [1] 0 and R returns its value, 0. We can assign a new value to this element if we want. Try: matrix_a[2, 3] = 7 and now take a look at matrix_a again. print(matrix_a) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 0 0 7 0 0 ## [3,] 0 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 Recall our vector b: b = cbind(6,7,8,9,10) To access its third element, you can simply write: b[3] ## [1] 8 3.4 The logical class This class is the result of logical comparisons, for example, if you type: 4 &gt; 3 ## [1] TRUE R returns true. If we save this in a variable l: l = 4 &gt; 3 and check l’s class: class(l) ## [1] &quot;logical&quot; R returns logical. In other programming languages, logicals are often called bools. A logical variable can only have two values, either TRUE or FALSE. 3.5 The list class The list class is a very flexible class, and thus, very useful. You can put anything inside a list, such as numbers: list1 = list(3, 2) or vectors: list2 = list(c(1, 2), c(3, 4)) you can also put objects of different classes in the same list: list3 = list(3, c(1, 2), &quot;lists are amazing!&quot;) and of course create list of lists: my_lists = list(list1, list2, list3) To check the contents of a list, you can use the structure function str(): str(my_lists) ## List of 3 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num [1:2] 1 2 ## ..$ : num [1:2] 3 4 ## $ :List of 3 ## ..$ : num 3 ## ..$ : num [1:2] 1 2 ## ..$ : chr &quot;lists are amazing!&quot; or you can use Rstudio’s Environment pane: You can also create named lists: list4 = list(&quot;a&quot; = 2, &quot;b&quot; = 8, &quot;c&quot; = &quot;this is a named list&quot;) and you can access the elements in two ways: list4[[1]] ## [1] 2 or, for named lists: list4$c ## [1] &quot;this is a named list&quot; Lists are used extensively because they are so flexible. You can build lists of datasets and apply functions to all the datasets at once, build lists of models, lists of plots, etc… In the later chapters we are going to learn all about them. 3.6 Exercises Exercise 1 Try to create the following vector: \\[a = (6,3,8,9)\\] and add it this other vector: \\[b = (9,1,3,5)\\] and save the result to a new variable called result. 3.6.1 Exercise 2 Using a and b from before, try to get their dot product. Try with a * b in the R console. What happened? Try to find the right function to get the dot product. Don’t hesitate to google the answer! 3.6.2 Exercise 3 How can you create a matrix of dimension (30,30) filled with 2’s by only using the function matrix()? 3.6.3 Exercise 4 Save your first name in a variable a and your surname in a variable b. What does the function: paste(a,b) do? Look at the help for paste() with ?paste or using the Help pane in Rstudio. What does the optional argument sep do? 3.6.4 Exercise 5 Define the following variables: a = 8, b = 3, c = 19. What do the following lines check? What do they return? a &gt; b a == b a != b a &lt; b (a &gt; b) &amp;&amp; (a &lt; c) (a &gt; b) &amp;&amp; (a &gt; c) (a &gt; b) || (a &lt; b) 3.6.5 Exercise 6 Define the following matrix: \\[ \\text{matrix_a} = \\left( \\begin{array}{ccc} 9 &amp; 4 &amp; 12 \\\\ 5 &amp; 0 &amp; 7 \\\\ 2 &amp; 6 &amp; 8 \\\\ 9 &amp; 2 &amp; 9 \\end{array} \\right) \\] What does matrix_a &gt;= 5 do? What does matrix_a[ , 2] do? Can you find which function gives you the transpose of this matrix? 3.6.6 Exercise 7 Solve the following system of equations using the solve() function: \\[ \\left( \\begin{array}{cccc} 9 &amp; 4 &amp; 12 &amp; 2 \\\\ 5 &amp; 0 &amp; 7 &amp; 9\\\\ 2 &amp; 6 &amp; 8 &amp; 0\\\\ 9 &amp; 2 &amp; 9 &amp; 11 \\end{array} \\right) \\times \\left( \\begin{array}{ccc} x \\\\ y \\\\ z \\\\ t \\\\ \\end{array}\\right) = \\left( \\begin{array}{ccc} 7\\\\ 18\\\\ 1\\\\ 0 \\end{array} \\right) \\] "],
["reading-and-writing-data.html", "Chapter 4 Reading and writing data", " Chapter 4 Reading and writing data R can import some formats without the need of external packages, such as the .csv format. However, for other formats, you will need to use different packages. Because there are a lot of different formats available I suggest you use rio. rio is basically a wrapper around every package that exists to import/export data. This package is nice because you don’t need to remember which package to use to import, say, STATA datasets. Read rio’s vignette for more details. Below I show some of rio’s functions presented in the vignette. To import data with rio, import() is all you need: mtcars = import(&quot;datasets/mtcars.csv&quot;) head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 import() needs the path to the data, and you can specify additional options if needed. Importing a STATA or a SAS file is done just the same: mtcars_stata = import(&quot;datasets/mtcars.dta&quot;) head(mtcars_stata) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 mtcars_sas = import(&quot;datasets/mtcars.sas7bdat&quot;) head(mtcars_sas) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 It is also possible to import Excel files where each sheet is a single table, but you will need import_list() for that. The file multi.xlsx has two sheets, each with a table in it: multi = import_list(&quot;datasets/multi.xlsx&quot;) str(multi) ## List of 2 ## $ :&#39;data.frame&#39;: 32 obs. of 11 variables: ## ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ... ## ..$ disp: num [1:32] 160 160 108 258 360 ... ## ..$ hp : num [1:32] 110 110 93 110 175 105 245 62 95 123 ... ## ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ... ## ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ... ## ..$ vs : num [1:32] 0 0 1 1 0 1 0 1 1 1 ... ## ..$ am : num [1:32] 1 1 1 0 0 0 0 0 0 0 ... ## ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ... ## ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ... ## $ :&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..$ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## ..$ Species : chr [1:150] &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; ... As you can see multi is a list of datasets. Told you lists were very flexible! It is also possible to import all the datasets in a single directory at once. For this, you first need a vector of paths: paths = Sys.glob(&quot;datasets/unemployment/*.csv&quot;) Sys.glob() allows you to find files using a regular expression. “datasets/unemployment/*.csv&quot; matches all the .csv files inside “datasets/unemployment”. all_data = import_list(paths) str(all_data) ## List of 4 ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duch? de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Population ayant un emploi au total: int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ dont: Salari?s : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ dont: Non-Salari?s : int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ Ch?meurs : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ Population active : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ Taux de ch?mage (en %) : num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duch? de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Population ayant un emploi au total: int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ dont: Salari?s : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ dont: Non-Salari?s : int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ Ch?meurs : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ Population active : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ Taux de ch?mage (en %) : num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duch? de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Population ayant un emploi au total: int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ dont: Salari?s : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ dont: Non-Salari?s : int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ Ch?meurs : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ Population active : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ Taux de ch?mage (en %) : num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duch? de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Population ayant un emploi au total: int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ dont: Salari?s : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ dont: Non-Salari?s : int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ Ch?meurs : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ Population active : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ Taux de ch?mage (en %) : num [1:118] 7.15 5.04 4.84 3.01 4.3 ... in a subsequent chapter we will learn how to actually use these lists of datasets. If something goes wrong, you might need to take a look at the underlying function rio is actually using to import the file. Let’s look at the following example: testdata = import(&quot;datasets/problems/mtcars.csv&quot;) head(testdata) ## mpg&amp;cyl&amp;disp&amp;hp&amp;drat&amp;wt&amp;qsec&amp;vs&amp;am&amp;gear&amp;carb ## 1 21&amp;6&amp;160&amp;110&amp;3.9&amp;2.62&amp;16.46&amp;0&amp;1&amp;4&amp;4 ## 2 21&amp;6&amp;160&amp;110&amp;3.9&amp;2.875&amp;17.02&amp;0&amp;1&amp;4&amp;4 ## 3 22.8&amp;4&amp;108&amp;93&amp;3.85&amp;2.32&amp;18.61&amp;1&amp;1&amp;4&amp;1 ## 4 21.4&amp;6&amp;258&amp;110&amp;3.08&amp;3.215&amp;19.44&amp;1&amp;0&amp;3&amp;1 ## 5 18.7&amp;8&amp;360&amp;175&amp;3.15&amp;3.44&amp;17.02&amp;0&amp;0&amp;3&amp;2 ## 6 18.1&amp;6&amp;225&amp;105&amp;2.76&amp;3.46&amp;20.22&amp;1&amp;0&amp;3&amp;1 as you can see, the import didn’t work quite well! This is because the separator is the &amp; for some reason. Because we are trying to read a .csv file, rio::import() is trying to use data.table::fread() under the hood (you can read this in imports()’s help). If you go and read data.table::fread()’s help, you see that the fread() has an optional sep = argument that you can use to specify the separator. You can use this argument in import() too, and it will be passed down to fread(): testdata = import(&quot;datasets/problems/mtcars.csv&quot;, sep = &quot;&amp;&quot;) head(testdata) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 "],
["descriptive-statistics.html", "Chapter 5 Descriptive statistics", " Chapter 5 Descriptive statistics We describe our methods in this chapter. "],
["graphs.html", "Chapter 6 Graphs 6.1 ggplot2", " Chapter 6 Graphs Some significant applications are demonstrated in this chapter. 6.1 ggplot2 "],
["programming-with-r.html", "Chapter 7 Programming with R 7.1 Writing your own functions", " Chapter 7 Programming with R 7.1 Writing your own functions "],
["statistical-models.html", "Chapter 8 Statistical models", " Chapter 8 Statistical models We have finished a nice book. "],
["references.html", "References", " References "]
]
