[
["index.html", "Modern R for STATEC Preface What is R? What is Rstudio? Prerequisites What are packages?", " Modern R for STATEC Bruno Rodrigues 2017-10-13 Preface What is R? Read R’s official answer to this question here. To make it short: R is multi-paradigm (procedural, imperative, object-oriented and functional)1 programming language that focuses on applications in statistics. By statistics I mean any field that uses statistics such as official statistics, economics, finance, data science, etc. What is Rstudio? Rstudio is a modern IDE that makes writing R code easier. The first thing we are going to learn is how to use it. R and Rstudio are both open source: this means that the source code is freely available on the internet and contributions by anyone are welcome and integrated; provided they are meaningful and useful. Prerequisites R and Rstudio are the two main pieces of software that we are going to use. Both are already installed on your desktop computer. R is the programming language and Rstudio is a modern IDE for it. You can use R without Rstudio; but you cannot use Rstudio without R. If you wish to install R and Rstudio at home to follow the examples in this book you can do it as both pieces of software are available free of charge (for firms paid options for Rstudio exist). Installation is simple, but operating system dependent. To download and install R for Windows, follow this link. For macOS, follow this one. If you run a GNU+Linux distribution, you can install R using the system’s package manager. On Ubuntu, install r-base. For Rstudio, look for your operating system here. What are packages? There is one more step; we are going to install some packages. Packages are additional pieces of code that can be installed from within R with the following function: install.packages(). These packages extend R’s capabilities significantly, and are probably one of the main reasons R is so popular. As of October 2017, R has over 11000 packages. To install the packages we need, first open Rstudio and then copy and paste this line in the console: install.packages(c(&quot;tidyverse&quot;, &quot;checkpoint&quot;, &quot;eurostat&quot;, &quot;ggthemes&quot;, &quot;janitor&quot;, &quot;openxlsx&quot;, &quot;rio&quot;)) or go to the Packages pane and then click on Install: The author My name is Bruno Rodrigues and I work in the research department of STATEC. I program almost exclusively in R and have been teaching some R courses for a few years now (first started teaching for students at the Université of Strasbourg). These notes are an update of those I used at the time, plus a lot of things I’ve learned about R since I started working at STATEC. I also am writing another book that is more advanced than this one. In my free time I like cooking, boxing and blogging. You can follow me on twitter if you’d like! In this book we are going to focus on R’s functional programming capabilities↩ "],
["getting-to-know-rstudio.html", "Chapter 1 Getting to know Rstudio 1.1 Panes 1.2 Console 1.3 Scripts 1.4 Options 1.5 Keyboard shortcuts 1.6 Projects 1.7 History 1.8 Plots", " Chapter 1 Getting to know Rstudio 1.1 Panes Rstudio is divided into different panes. Each pane has a specific function. The gif below shows some of these panes: Take some time to look around what each pane shows you. Some panes are empty; for example the Plots pane or the Viewer pane. Plots shows you the plots you make. You can browse the plots and save them. We will see this in more detail in a later chapter. Viewer shows you previews of documents that you generate with R. More on this later. 1.2 Console The Console pane is where you can execute R code. Write the following in the console: 2 + 3 and you’ll get the answer, 5. However, do not write a lot of lines in the console. It is better write your code inside a script. 1.3 Scripts Look at the gif below: In this gif, we see the user creating a new R script. R scripts are simple text files that hold R code. Think of .do files in STATA or .c files for C. R scripts have the extension .r or .R. It is possible to create a lot of other files. We’ll take a look at R Markdown files later. 1.3.1 The help pane The Help pane allows you to consult documentation for functions or packages. The gif below shows how it works: you can also access help using the following syntax: ?lm. This will bring up the documentation for the function lm(). You can also type ??lm which will look for the string lm in every package. 1.3.2 The Environment pane The Environment pane shows every object created in the current section. It is especially useful if you have defined lists or have loaded data into R as it makes it easy to explore these more complex objects. 1.4 Options It is also possible to customize Rstudio’s look and feel: Take some time to go through the options. 1.5 Keyboard shortcuts It is a good idea to familiarize yourself with at least some keyboard shortcuts. This is more convenient than having to move the mouse around: If there is only one keyboard shortcut you need to know, it’s Ctrl-Enter that executes a line of code from your script. However, these other shortcuts are also worth knowing: CTRL-ALT-R: run entire script CTRL-ALT-UP or DOWN: make cursor taller or shorter, allowing you to edit multiple lines at the same time CTRL-F: Search and replace ALT-UP or DOWN: Move line up or down CTRL-SHIFT-C: Comment/uncomment line ALT-SHIFT-K: Bring up the list of keyboard shortcuts CTRL-SHIFT-M: Insert the pipe operator (%&gt;%, more on this later) CTRL-S: Save script This is just a few keyboard shortcuts that I personally find useful. However, I strongly advise you to learn and use whatever shortcuts are useful to you! 1.6 Projects One of the best features of Rstudio are projects. Creating a project is simple; the gif below shows how you can create a project and how you can switch between projects. Projects make a lot of things easier, such as managing paths. More on this in the chapter about reading data. Another useful feature of projects is that the scripts you open in project A will stay open even if you switch to another project B, and then switch back to the project A again. You can also use version control (with git) inside a project. Version control is very useful, but I won’t discuss it here. You can find a lot of resources online to get you started with git. 1.7 History The history pane saves all the previous lines you executed. You can then select these lines and send them back to the console or the script. 1.8 Plots All the plots you make during a session are visible in the Plots pane. From there, you can export them in different formats. The plots shown in the gif are made using basic R functions. Later, we will learn how to make nicer looking plots using the package ggplot2. "],
["packages.html", "Chapter 2 Packages", " Chapter 2 Packages You can think of packages as addons that extend R’s core functionality. You can browse all available package on CRAN. To make it easier to find what you might be interested in, you can also browes the CRAN Task Views. Each package has a landing page that summarises its dependencies, version number etc. For example, for the dplyr package: https://cran.r-project.org/web/packages/dplyr/index.html. Take a look at the Downloads section, and especially at the Reference Manual and Vignettes: Vignettes are valuable documents; inside vignettes, the purpose of the package is explained in plain English, usually with accompanying examples. The reference manuals list the available functions inside the packages. You can also find vignettes from within Rstudio: Go to the Packages pane and click on the package you’re interested in. Then you can consult the help for the functions that come with the package as well as the package’s vignettes. Once you installed a package, you have to load it before you can use it. To load packages you use the library() function: library(dplyr) library(janitor) # and so on... If you only need to use one single function once, you don’t need to load an entire package. You can write the following: dplyr::full_join(A, B) using the :: operator, you can access functions from packages without having to load the whole package beforehand. It is possible and easy to create your own packages. This is useful if you have to write a lot of functions that you use daily. This is outside the scope of this book, but if you’re interested you can read this other one I wrote. "],
["data-types-and-objects.html", "Chapter 3 Data types and objects 3.1 The numeric class 3.2 The character class 3.3 Vectors and matrices 3.4 The logical class 3.5 The list class 3.6 The data.frame and tibble classes 3.7 Exercises", " Chapter 3 Data types and objects R use a variety of data types. You already know most of them, actually! Integers (), floating point numbers, or floats (), matrices, etc, are all objects you already use on a daily basis. But R has a lot of other data types (that you can find in a lot of other programming languages) that you need to become familiar with. But first, we need to learn how to assign a variable. This can be done in two ways: a = 3 or a = 3 there is almost no difference between these two approaches. Out of habit, I use =, but you can use = if you wish. 3.1 The numeric class To define single numbers, you can do the following: a = 3 The class() function allows you to check the class of an object: class(a) ## [1] &quot;numeric&quot; Decimals are defined with the character `.}: a = 3.14 3.2 The character class Use &quot; &quot; to define characters (called strings in other programming languages): a = &quot;this is a string&quot; class(a) ## [1] &quot;character&quot; 3.3 Vectors and matrices You can create a vector in different ways. But first of all, it is important to understand that a vector in most programming languages is nothing more than a list of things. These things can be numbers (either integers or floats), strings, or even other vectors. The same applies for matrices. 3.3.1 The c() function matrix_a very important function that allows you to build a vector is c(): a = c(1,2,3,4,5) This creates a vector with elements 1, 2, 3, 4, 5. If you check its class: class(a) ## [1] &quot;numeric&quot; This can be confusing: you where probably expecting a to be of class or something similar. This is not the case if you use c() to create the vector, because c() doesn’t build a vector in the mathematical sense, but rather a list with numbers. Checking its dimension: dim(a) ## NULL matrix_a list doesn’t have a dimension, that’s why the dim() command returns NULL. If you want to create a true vector, you need to use cbind() or rbind(). 3.3.2 cbind() and rbind() You can create a true vector with cbind(): a = cbind(1,2,3,4,5) Check its class now: class(a) ## [1] &quot;matrix&quot; This is exactly what we expected. Let’s check its dimension: dim(a) ## [1] 1 5 This returns the dimension of a using the LICO notation (number of LInes first, the number of COlumns). It is also possible to bind vectors together to create a matrix. b = cbind(6,7,8,9,10) Now let’s put vector a and b into a matrix called matrix_c using rbind(). rbind() functions the same way as cbind() but glues the vectors together by rows and not by columns. matrix_c = rbind(a,b) print(matrix_c) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 3.3.3 The matrix class R also has support for matrices. For example, you can create a matrix of dimension (5,5) filled with 0’s with the matrix() function: matrix_a = matrix(0, nrow = 5, ncol = 5) If you want to create the following matrix: \\[ B = \\left( \\begin{array}{ccc} 2 &amp; 4 &amp; 3 \\\\ 1 &amp; 5 &amp; 7 \\end{array} \\right) \\] you would do it like this: B = matrix(c(2, 4, 3, 1, 5, 7), nrow = 2, byrow = TRUE) The option byrow = TRUE means that the rows of the matrix will be filled first. You can access individual elements of matrix_A like so: matrix_a[2, 3] ## [1] 0 and R returns its value, 0. We can assign a new value to this element if we want. Try: matrix_a[2, 3] = 7 and now take a look at matrix_a again. print(matrix_a) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0 0 0 0 0 ## [2,] 0 0 7 0 0 ## [3,] 0 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 Recall our vector b: b = cbind(6,7,8,9,10) To access its third element, you can simply write: b[3] ## [1] 8 3.4 The logical class This class is the result of logical comparisons, for example, if you type: 4 &gt; 3 ## [1] TRUE R returns true. If we save this in a variable l: l = 4 &gt; 3 and check l’s class: class(l) ## [1] &quot;logical&quot; R returns logical. In other programming languages, logicals are often called bools. A logical variable can only have two values, either TRUE or FALSE. 3.5 The list class The list class is a very flexible class, and thus, very useful. You can put anything inside a list, such as numbers: list1 = list(3, 2) or vectors: list2 = list(c(1, 2), c(3, 4)) you can also put objects of different classes in the same list: list3 = list(3, c(1, 2), &quot;lists are amazing!&quot;) and of course create list of lists: my_lists = list(list1, list2, list3) To check the contents of a list, you can use the structure function str(): str(my_lists) ## List of 3 ## $ :List of 2 ## ..$ : num 3 ## ..$ : num 2 ## $ :List of 2 ## ..$ : num [1:2] 1 2 ## ..$ : num [1:2] 3 4 ## $ :List of 3 ## ..$ : num 3 ## ..$ : num [1:2] 1 2 ## ..$ : chr &quot;lists are amazing!&quot; or you can use Rstudio’s Environment pane: You can also create named lists: list4 = list(&quot;a&quot; = 2, &quot;b&quot; = 8, &quot;c&quot; = &quot;this is a named list&quot;) and you can access the elements in two ways: list4[[1]] ## [1] 2 or, for named lists: list4$c ## [1] &quot;this is a named list&quot; Lists are used extensively because they are so flexible. You can build lists of datasets and apply functions to all the datasets at once, build lists of models, lists of plots, etc… In the later chapters we are going to learn all about them. 3.6 The data.frame and tibble classes In the next chapter we are going to learn how to import datasets into R. Once you import data, the resulting object is either a data.frame or a tibble depending on which package you used to import the data. tibbles extend data.frames so if you know about data.frame objects already, working with tibbles will be very easy. tibbles have a better print() method, and some other niceties. If you want to know more, I go into more detail in my other book but for our purposes, there’s not much you need to know about data.frame and tibble objects, apart that this the representation of a dataset when loaded into R. 3.7 Exercises Exercise 1 Try to create the following vector: \\[a = (6,3,8,9)\\] and add it this other vector: \\[b = (9,1,3,5)\\] and save the result to a new variable called result. 3.7.1 Exercise 2 Using a and b from before, try to get their dot product. Try with a * b in the R console. What happened? Try to find the right function to get the dot product. Don’t hesitate to google the answer! 3.7.2 Exercise 3 How can you create a matrix of dimension (30,30) filled with 2’s by only using the function matrix()? 3.7.3 Exercise 4 Save your first name in a variable a and your surname in a variable b. What does the function: paste(a,b) do? Look at the help for paste() with ?paste or using the Help pane in Rstudio. What does the optional argument sep do? 3.7.4 Exercise 5 Define the following variables: a = 8, b = 3, c = 19. What do the following lines check? What do they return? a &gt; b a == b a != b a &lt; b (a &gt; b) &amp;&amp; (a &lt; c) (a &gt; b) &amp;&amp; (a &gt; c) (a &gt; b) || (a &lt; b) 3.7.5 Exercise 6 Define the following matrix: \\[ \\text{matrix_a} = \\left( \\begin{array}{ccc} 9 &amp; 4 &amp; 12 \\\\ 5 &amp; 0 &amp; 7 \\\\ 2 &amp; 6 &amp; 8 \\\\ 9 &amp; 2 &amp; 9 \\end{array} \\right) \\] What does matrix_a &gt;= 5 do? What does matrix_a[ , 2] do? Can you find which function gives you the transpose of this matrix? 3.7.6 Exercise 7 Solve the following system of equations using the solve() function: \\[ \\left( \\begin{array}{cccc} 9 &amp; 4 &amp; 12 &amp; 2 \\\\ 5 &amp; 0 &amp; 7 &amp; 9\\\\ 2 &amp; 6 &amp; 8 &amp; 0\\\\ 9 &amp; 2 &amp; 9 &amp; 11 \\end{array} \\right) \\times \\left( \\begin{array}{ccc} x \\\\ y \\\\ z \\\\ t \\\\ \\end{array}\\right) = \\left( \\begin{array}{ccc} 7\\\\ 18\\\\ 1\\\\ 0 \\end{array} \\right) \\] "],
["reading-and-writing-data-with-rio.html", "Chapter 4 Reading and writing data with rio", " Chapter 4 Reading and writing data with rio In this chapter, we are going to import example datasets that are available in R, mtcars and iris. I have converted these datasets into several formats. Download those datasets here if you want to follow the examples below. R can import some formats without the need of external packages, such as the .csv format. However, for other formats, you will need to use different packages. Because there are a lot of different formats available I suggest you use rio. rio is basically a wrapper around a lot of packages that exist to import/export data. This package is nice because you don’t need to remember which package to use to import, say, STATA datasets and then you need to remember which one for SAS datasets, and so on. Read rio’s vignette for more details. Below I show some of rio’s functions presented in the vignette. It is also possible to import data from other, less “traditional” sources, such as your clipboard. To import data with rio, import() is all you need: library(rio) mtcars = import(&quot;datasets/mtcars.csv&quot;) head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 import() needs the path to the data, and you can specify additional options if needed. Importing a STATA or a SAS file is done just the same: mtcars_stata = import(&quot;datasets/mtcars.dta&quot;) head(mtcars_stata) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 mtcars_sas = import(&quot;datasets/mtcars.sas7bdat&quot;) head(mtcars_sas) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 It is also possible to import Excel files where each sheet is a single table, but you will need import_list() for that. The file multi.xlsx has two sheets, each with a table in it: multi = import_list(&quot;datasets/multi.xlsx&quot;) str(multi) ## List of 2 ## $ :&#39;data.frame&#39;: 32 obs. of 11 variables: ## ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ... ## ..$ disp: num [1:32] 160 160 108 258 360 ... ## ..$ hp : num [1:32] 110 110 93 110 175 105 245 62 95 123 ... ## ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## ..$ wt : num [1:32] 2.62 2.88 2.32 3.21 3.44 ... ## ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ... ## ..$ vs : num [1:32] 0 0 1 1 0 1 0 1 1 1 ... ## ..$ am : num [1:32] 1 1 1 0 0 0 0 0 0 0 ... ## ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ... ## ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ... ## $ :&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..$ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## ..$ Species : chr [1:150] &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; &quot;setosa&quot; ... As you can see multi is a list of datasets. Told you lists were very flexible! It is also possible to import all the datasets in a single directory at once. For this, you first need a vector of paths: paths = Sys.glob(&quot;datasets/unemployment/*.csv&quot;) Sys.glob() allows you to find files using a regular expression. “datasets/unemployment/*.csv&quot; matches all the .csv files inside “datasets/unemployment”. all_data = import_list(paths) str(all_data) ## List of 4 ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of which: Wage-earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of which: Non-wage-earners: int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ Unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ Active population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of which: Wage-earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of which: Non-wage-earners: int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ Unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ Active population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of which: Wage-earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of which: Non-wage-earners: int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ Active population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of which: Wage-earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of which: Non-wage-earners: int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ Active population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.15 5.04 4.84 3.01 4.3 ... in a subsequent chapter we will learn how to actually use these lists of datasets. If something goes wrong, you might need to take a look at the underlying function rio is actually using to import the file. Let’s look at the following example: testdata = import(&quot;datasets/problems/mtcars.csv&quot;) head(testdata) ## mpg&amp;cyl&amp;disp&amp;hp&amp;drat&amp;wt&amp;qsec&amp;vs&amp;am&amp;gear&amp;carb ## 1 21&amp;6&amp;160&amp;110&amp;3.9&amp;2.62&amp;16.46&amp;0&amp;1&amp;4&amp;4 ## 2 21&amp;6&amp;160&amp;110&amp;3.9&amp;2.875&amp;17.02&amp;0&amp;1&amp;4&amp;4 ## 3 22.8&amp;4&amp;108&amp;93&amp;3.85&amp;2.32&amp;18.61&amp;1&amp;1&amp;4&amp;1 ## 4 21.4&amp;6&amp;258&amp;110&amp;3.08&amp;3.215&amp;19.44&amp;1&amp;0&amp;3&amp;1 ## 5 18.7&amp;8&amp;360&amp;175&amp;3.15&amp;3.44&amp;17.02&amp;0&amp;0&amp;3&amp;2 ## 6 18.1&amp;6&amp;225&amp;105&amp;2.76&amp;3.46&amp;20.22&amp;1&amp;0&amp;3&amp;1 as you can see, the import didn’t work quite well! This is because the separator is the &amp; for some reason. Because we are trying to read a .csv file, rio::import() is trying to use data.table::fread() under the hood (you can read this in imports()’s help). If you go and read data.table::fread()’s help, you see that the fread() has an optional sep = argument that you can use to specify the separator. You can use this argument in import() too, and it will be passed down to fread(): testdata = import(&quot;datasets/problems/mtcars.csv&quot;, sep = &quot;&amp;&quot;) head(testdata) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 export() allows you to write data to disk, by simply providing the path and name of the file you wish to save. export(testdata, &quot;path/where/to/save/testdata.csv&quot;) If you end the name with .csv the file is exported to the csv format, if instead you write .dta the data will be exported to the STATA format, etc. If you wish to export to Excel, this is possible, but requires that you change a file on your computer (you only have to do this once). Run the following lines in Rstudio: if(!file.exists(&quot;~/.Rprofile&quot;)) # only create if not already there file.create(&quot;~/.Rprofile&quot;) # (don&#39;t overwrite it) file.edit(&quot;~/.Rprofile&quot;) These lines, taken shamelessly from Efficient R programming (go read it, it’s a very great resource) look for and open the .Rprofile file which is a file that is run every time you open Rstudio. This means that you can put any line of code there that will always be executed whenever you launch Rstudio. The line you need to add is this: Sys.setenv(&quot;R_ZIPCMD&quot; = &quot;C:/Program Files (x86)/Rtools/zip.exe&quot;) This tells Rstudio to use zip.exe as the default zip tool, which is needed to export files to the Excel format. Try it out by restarting Rstudio, and then running the following lines: library(rio) data(mtcars) export(mtcars, &quot;mtcars.xlsx&quot;) You should find the mtcars.xlsx inside your working directory (it should be your Documents folder. You can use getwd() to check where you are). rio should cover all your needs, but if not, there is very likely a package out there that will import the data you need. "],
["data-manipulation-and-descriptive-statistics.html", "Chapter 5 Data manipulation and descriptive statistics 5.1 Working with a single dataset 5.2 Working with a list of datasets", " Chapter 5 Data manipulation and descriptive statistics Now that we are familiar with some R objects and know how to import data, it is time to actually write some code. In this chapter, we are going to compute descriptive statistics for a single dataset, but also for a list of datasets. However, I will not give a list of functions to compute descriptive statistics; if you need a specific function you can find easily in the Help pane in Rstudio or using any modern internet searh engine. What I will do is show you a workflow that allows you to compute the statisics you need fast. R has a lot of built-in functions for descriptive statistics; however, if you want to compute statistics by, say, gender, some more complex manipulations are needed. At least this was true in the past. Nowadays, thanks to the packages from the tidyverse (remember those we installed at the beginning of the book?), it is very easy and fast to compute descriptive statistics by any stratifying variable(s). The package we are going to use for this is called dplyr. dplyr contains a lot of functions that make manipulating data and computing descriptive statistics very easy. To make things easier for now, we are going to use example data included with dplyr. So no need to import an external dataset; this does not change anything to the example that we are going to study here; the source of the data does not matter for this. 5.1 Working with a single dataset First, let’s load dplyr and the included starwars dataset. Let’s also take a look at the first 5 lines of the dataset: library(dplyr) data(starwars) head(starwars) ## # A tibble: 6 x 13 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Luke Skywalker 172 77 blond fair blue 19.0 ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112.0 ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red 33.0 ## 4 Darth Vader 202 136 none white yellow 41.9 ## 5 Leia Organa 150 49 brown light brown 19.0 ## 6 Owen Lars 178 120 brown, grey light blue 52.0 ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; data(starwars) loads the example dataset called starwars that is included in the package dplyr. As I said earlier, this is just an example; you could have loaded an external dataset, from a .csv for instance. This does not matter for what comes next. R includes a lot of function for descriptive statistics, such as mean(), sd(), cov(), and many more. What dplyr brings to the table is the possibility to apply these functions to the dataset easily. For example, imagine you want the average height of everyone in the dataset. Using the basic R functions, you could write this: mean(starwars$height) ## [1] NA starwars$height means that the user wants to access the column called height from the dataset starwars. This is then given as an argument to the function mean(). But what if the user wants the average height by species? Before dplyr, a solution to this simple problem would have required more than a single command. Now this is as easy as: starwars %&gt;% group_by(species) %&gt;% summarise(mean(height)) ## # A tibble: 38 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Clawdite 168.0000 ## 6 Droid NA ## 7 Dug 112.0000 ## 8 Ewok 88.0000 ## 9 Geonosian 183.0000 ## 10 Gungan 208.6667 ## # ... with 28 more rows Ok, I know what you’re thinking. What the hell is this weird %&gt;% thing?. That weird thing is called the pipe operator. What it does is taking the left-hand side argument and piping it as the first argument of the function on the right-hand side. Try the following in the command line: 4 %&gt;% sqrt() ## [1] 2 It is equivalent to sqrt(4). Why use that though? You will see in the next examples that using the %&gt;% makes writing and reading code, much, much easier. For example, the previous manipulation I did could be read as “Take the starwars data, give it to the group_by() function and then compute the mean height”. Without the %&gt;%, one would need to write: summarise(group_by(starwars, species), mean(height)) ## # A tibble: 38 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Clawdite 168.0000 ## 6 Droid NA ## 7 Dug 112.0000 ## 8 Ewok 88.0000 ## 9 Geonosian 183.0000 ## 10 Gungan 208.6667 ## # ... with 28 more rows as you can see, it is much more difficult to read. Imagine now that I want average height by species, but only for males. Again, this is very easy using %&gt;%: starwars %&gt;% filter(gender == &quot;male&quot;) %&gt;% group_by(species) %&gt;% summarise(mean(height)) ## # A tibble: 32 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Dug 112.0000 ## 6 Ewok 88.0000 ## 7 Geonosian 183.0000 ## 8 Gungan 208.6667 ## 9 Human NA ## 10 Iktotchi 188.0000 ## # ... with 22 more rows Again, the %&gt;% makes the above lines of code very easy to read. Without it, one would write: summarise(group_by(filter(starwars, gender == &quot;male&quot;), species), mean(height)) ## # A tibble: 32 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Dug 112.0000 ## 6 Ewok 88.0000 ## 7 Geonosian 183.0000 ## 8 Gungan 208.6667 ## 9 Human NA ## 10 Iktotchi 188.0000 ## # ... with 22 more rows I think you agree with me that this is not very readable. To make things clearer; filter(), group_by() and summarise() are functions that are included in dplyr. %&gt;% is actually a function from magrittr, but this package gets loaded when you load dplyr automatically, so you do not need to worry about it. mean() is a function native to R. Another thing very nice about using dplyr; the result of all these operations are datasets, or tibbles. This means that you can save them in variable, and then work with these as any other datasets. mean_height = starwars %&gt;% group_by(species) %&gt;% summarise(mean(height)) class(mean_height) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; head(mean_height) ## # A tibble: 6 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Clawdite 168 ## 6 Droid NA You could then write this data to disk using rio::export() for instance. If you need more than the mean of the height, you can keep adding as many functions as needed: summary_table = starwars %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height), var_height = var(height), n_obs = n()) print(summary_table) ## # A tibble: 38 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Aleena 79.0000 NA 1 ## 2 Besalisk 198.0000 NA 1 ## 3 Cerean 198.0000 NA 1 ## 4 Chagrian 196.0000 NA 1 ## 5 Clawdite 168.0000 NA 1 ## 6 Droid NA NA 5 ## 7 Dug 112.0000 NA 1 ## 8 Ewok 88.0000 NA 1 ## 9 Geonosian 183.0000 NA 1 ## 10 Gungan 208.6667 201.3333 3 ## # ... with 28 more rows I did several things there; I’ve added more functions, var() to get the variance and n() (which is a function from dplyr, not base R) to get the number of observations. This is quite useful, because we see that for a lot of species we only have one single individual! Let’s focus on the species for which we have more than 1 individual. Since we save all the previous operations (which produce a tibble) in a variable, we can keep going from there: summary_table2 = summary_table %&gt;% filter(n_obs &gt; 1) print(summary_table2) ## # A tibble: 9 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid NA NA 5 ## 2 Gungan 208.6667 201.3333 3 ## 3 Human NA NA 35 ## 4 Kaminoan 221.0000 128.0000 2 ## 5 Mirialan 168.0000 8.0000 2 ## 6 Twi&#39;lek 179.0000 2.0000 2 ## 7 Wookiee 231.0000 18.0000 2 ## 8 Zabrak 173.0000 8.0000 2 ## 9 &lt;NA&gt; NA NA 5 There’s a lot of NAs; this is because by default, mean() and var() return NA if even one single observation is NA (unlike STATA). mean() and var() have a na.rm option that the user can set to TRUE to get the result by ignoring the NAs: starwars %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 9 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid 140.0000 2704.6667 5 ## 2 Gungan 208.6667 201.3333 3 ## 3 Human 176.6452 157.1699 35 ## 4 Kaminoan 221.0000 128.0000 2 ## 5 Mirialan 168.0000 8.0000 2 ## 6 Twi&#39;lek 179.0000 2.0000 2 ## 7 Wookiee 231.0000 18.0000 2 ## 8 Zabrak 173.0000 8.0000 2 ## 9 &lt;NA&gt; 160.0000 1826.0000 5 In the code above, I have combined the two previous steps to get the result I’m interested in. There’s a line in the final output that says NA for the spcies. Let’s go back to the raw data and find this line with the function which() (which is a basic R function): na_species &lt;- which(is.na(starwars$species)) starwars[na_species, ] ## # A tibble: 5 x 13 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ric Olié 183 NA brown fair blue NA ## 2 Quarsh Panaka 183 NA black dark brown 62 ## 3 R4-P17 96 NA none silver, red red, blue NA ## 4 Sly Moore 178 48 none pale white NA ## 5 Captain Phasma NA NA unknown unknown unknown NA ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; To test for NA, one uses the function is.na() and then which() returns the index where this condition is TRUE. So what I did above is save the row number where species is NA and then using the [] I slive the original raw data to get the entire line. As you can see, there’s a few of them. An alternative way of doing that, using dplyr would be the following: starwars %&gt;% filter(is.na(species)) ## # A tibble: 5 x 13 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ric Olié 183 NA brown fair blue NA ## 2 Quarsh Panaka 183 NA black dark brown 62 ## 3 R4-P17 96 NA none silver, red red, blue NA ## 4 Sly Moore 178 48 none pale white NA ## 5 Captain Phasma NA NA unknown unknown unknown NA ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; or if you want to remove these lines: starwars %&gt;% filter(!is.na(species)) ## # A tibble: 82 x 13 ## name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywalker 172 77 blond fair blue ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red ## 4 Darth Vader 202 136 none white yellow ## 5 Leia Organa 150 49 brown light brown ## 6 Owen Lars 178 120 brown, grey light blue ## 7 Beru Whitesun lars 165 75 brown light blue ## 8 R5-D4 97 32 &lt;NA&gt; white, red red ## 9 Biggs Darklighter 183 84 black light brown ## 10 Obi-Wan Kenobi 182 77 auburn, white fair blue-gray ## # ... with 72 more rows, and 7 more variables: birth_year &lt;dbl&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; The !() function negates a predicate function (a predicate function is a function that returns TRUE or FALSE). We can then rerun our analysis from before: starwars %&gt;% filter(!is.na(species)) %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 8 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid 140.0000 2704.6667 5 ## 2 Gungan 208.6667 201.3333 3 ## 3 Human 176.6452 157.1699 35 ## 4 Kaminoan 221.0000 128.0000 2 ## 5 Mirialan 168.0000 8.0000 2 ## 6 Twi&#39;lek 179.0000 2.0000 2 ## 7 Wookiee 231.0000 18.0000 2 ## 8 Zabrak 173.0000 8.0000 2 dplyr contains a lot of different functions, one of which is mutate(). mutate() allows you to create new columns. For instance, suppose you need a column of the height of the individuals in meters, and not in centimeters: starwars = starwars %&gt;% mutate(height_m = height/100) glimpse(starwars) ## Observations: 87 ## Variables: 14 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, ... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188... ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 8... ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;b... ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;l... ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;,... ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,... ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alder... ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human... ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;Th... ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;,... ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Adva... ## $ height_m &lt;dbl&gt; 1.72, 1.67, 0.96, 2.02, 1.50, 1.78, 1.65, 0.97, 1.8... I have used mutate() to compute the column I need and glimpse() is an alternative to print() that I find very interesting. We can see the column we created at the very bottom. It might be interesting to reorder the columns; this is possible with select() another dplyr function: starwars = starwars %&gt;% select(name, height, height_m, everything()) glimpse(starwars) ## Observations: 87 ## Variables: 14 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, ... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188... ## $ height_m &lt;dbl&gt; 1.72, 1.67, 0.96, 2.02, 1.50, 1.78, 1.65, 0.97, 1.8... ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 8... ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;b... ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;l... ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;,... ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,... ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alder... ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human... ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;Th... ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;,... ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Adva... select() allows you to reorder columns by writing the order of the columns you want, and then you can use everything() (another dplyr function) to just tell select() that you want everything else in there. But select() also allows you to only select a subset of columns, if needed: starwars %&gt;% select(name, height, height_m, gender) %&gt;% glimpse() ## Observations: 87 ## Variables: 4 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, &quot;L... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, ... ## $ height_m &lt;dbl&gt; 1.72, 1.67, 0.96, 2.02, 1.50, 1.78, 1.65, 0.97, 1.83,... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, N... The last thing I want to show you are the so-called scoped version of these functions. For example, what if I am only interested in columns that contains text? Is there a way to select them automatically? For this type of tasks, you can use select_if(): starwars %&gt;% select_if(is.character) ## # A tibble: 87 x 7 ## name hair_color skin_color eye_color gender homeworld ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywalker blond fair blue male Tatooine ## 2 C-3PO &lt;NA&gt; gold yellow &lt;NA&gt; Tatooine ## 3 R2-D2 &lt;NA&gt; white, blue red &lt;NA&gt; Naboo ## 4 Darth Vader none white yellow male Tatooine ## 5 Leia Organa brown light brown female Alderaan ## 6 Owen Lars brown, grey light blue male Tatooine ## 7 Beru Whitesun lars brown light blue female Tatooine ## 8 R5-D4 &lt;NA&gt; white, red red &lt;NA&gt; Tatooine ## 9 Biggs Darklighter black light brown male Tatooine ## 10 Obi-Wan Kenobi auburn, white fair blue-gray male Stewjon ## # ... with 77 more rows, and 1 more variables: species &lt;chr&gt; select_if() selects every column that is of type character. There is also select_all() and select_at(), each with they’re own use. I will not go into more detail here. If you are interested, I advise you read dplyr’s help and also the section I wrote in my other book which goes into much more detail. 5.2 Working with a list of datasets Let’s read the list of datasets from the previous chapter: paths = Sys.glob(&quot;datasets/unemployment/*.csv&quot;) all_datasets = import_list(paths) str(all_datasets) ## List of 4 ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of which: Wage-earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of which: Non-wage-earners: int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ Unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ Active population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of which: Wage-earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of which: Non-wage-earners: int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ Unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ Active population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of which: Wage-earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of which: Non-wage-earners: int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ Active population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of which: Wage-earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of which: Non-wage-earners: int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ Active population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.15 5.04 4.84 3.01 4.3 ... For working with lists, another package from the tidyverse is very useful, and that would be purrr. purrr has functions to work with lists, and we are going to focus on two of them, map() and reduce(). map()… maps a function to each element of a list. reduce() is a bit more complicated so we’ll leave that for later. The first thing we are going to do is use a function to clean the names of the datasets. These names are not very easy to work with; there’s spaces, and it would be better if the names of the columns would be all lowercase. For this we are going to use the function clean_names() from the janitor package. For a sing dataset, I would write this: library(janitor) one_dataset = one_dataset %&gt;% clean_names() and I would get a dataset with column names in lowercase and spaces replaced by _. How can I apply, or map, this function to each dataset in the list? To do this I need to use purrr::map(): library(purrr) all_datasets = all_datasets %&gt;% map(clean_names) all_datasets %&gt;% glimpse() ## List of 4 ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of_which_wage_earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of_which_non_wage_earners : int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ active_population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of_which_wage_earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of_which_non_wage_earners : int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ active_population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of_which_wage_earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of_which_non_wage_earners : int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ active_population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of_which_wage_earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of_which_non_wage_earners : int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ active_population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.15 5.04 4.84 3.01 4.3 ... So now, what if I want to know, for each dataset, which communes have an unemployment rate that is less than, say, 3%? For a single dataset I would do something like this: all_datasets %&gt;% map(~filter(., unemployment_rate_in_percent &lt; 3)) ## [[1]] ## commune total_employed_population of_which_wage_earners ## 1 Garnich 844 750 ## 2 Leudelange 1064 937 ## 3 Bech 526 463 ## of_which_non_wage_earners unemployed active_population ## 1 94 25 869 ## 2 127 32 1096 ## 3 63 16 542 ## unemployment_rate_in_percent ## 1 2.876870 ## 2 2.919708 ## 3 2.952030 ## ## [[2]] ## commune total_employed_population of_which_wage_earners ## 1 Garnich 845 757 ## 2 Leudelange 1102 965 ## 3 Bech 543 476 ## 4 Flaxweiler 879 789 ## of_which_non_wage_earners unemployed active_population ## 1 88 19 864 ## 2 137 34 1136 ## 3 67 15 558 ## 4 90 27 906 ## unemployment_rate_in_percent ## 1 2.199074 ## 2 2.992958 ## 3 2.688172 ## 4 2.980132 ## ## [[3]] ## commune total_employed_population of_which_wage_earners ## 1 Bech 520 450 ## 2 Bous 750 680 ## of_which_non_wage_earners unemployed active_population ## 1 70 14 534 ## 2 70 22 772 ## unemployment_rate_in_percent ## 1 2.621723 ## 2 2.849741 ## ## [[4]] ## commune total_employed_population of_which_wage_earners ## 1 Reckange-sur-Mess 980 850 ## 2 Bech 520 450 ## 3 Betzdorf 1500 1350 ## 4 Flaxweiler 910 820 ## of_which_non_wage_earners unemployed active_population ## 1 130 30 1010 ## 2 70 11 531 ## 3 150 45 1545 ## 4 90 24 934 ## unemployment_rate_in_percent ## 1 2.970297 ## 2 2.071563 ## 3 2.912621 ## 4 2.569593 I know what you’re thinking… what the hell?. Let me explain: map() needs a function to map to each element of the list. all_datasets is the list to which I want to map the function. But what function? filter() is the function I need, so why doesn’t: all_datasets %&gt;% map(filter(unemployment_rate_in_percent &lt; 3)) work? This is a bit complicated, and has to do with what is called environments. If you try to run the code above, you will get this error message: Error in filter(unemployment_rate_in_percent &lt; 3) : object &#39;unemployment_rate_in_percent&#39; not found I won’t go into details, but by writing ~filter(., unemployment_rate_in_percent &lt; 3), which is a formula (~ is the symbol to define formulas, more on this in the later chapters), map() converts it to a function that can be used. "],
["graphs.html", "Chapter 6 Graphs 6.1 ggplot2", " Chapter 6 Graphs Some significant applications are demonstrated in this chapter. 6.1 ggplot2 "],
["statistical-models.html", "Chapter 7 Statistical models", " Chapter 7 Statistical models We have finished a nice book. "],
["programming-with-r.html", "Chapter 8 Programming with R 8.1 Writing your own functions", " Chapter 8 Programming with R 8.1 Writing your own functions "],
["references.html", "References", " References "]
]
