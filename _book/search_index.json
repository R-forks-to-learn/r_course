[
["data-manipulation-and-descriptive-statistics.html", "Chapter 5 Data manipulation and descriptive statistics 5.1 Working with a single dataset 5.2 Working with a list of datasets", " Chapter 5 Data manipulation and descriptive statistics Now that we are familiar with some R objects and know how to import data, it is time to actually write some code. In this chapter, we are going to compute descriptive statistics for a single dataset, but also for a list of datasets. However, I will not give a list of functions to compute descriptive statistics; if you need a specific function you can find easily in the Help pane in Rstudio or using any modern internet searh engine. What I will do is show you a workflow that allows you to compute the statisics you need fast. R has a lot of built-in functions for descriptive statistics; however, if you want to compute statistics by, say, gender, some more complex manipulations are needed. At least this was true in the past. Nowadays, thanks to the packages from the tidyverse (remember those we installed at the beginning of the book?), it is very easy and fast to compute descriptive statistics by any stratifying variable(s). The package we are going to use for this is called dplyr. dplyr contains a lot of functions that make manipulating data and computing descriptive statistics very easy. To make things easier for now, we are going to use example data included with dplyr. So no need to import an external dataset; this does not change anything to the example that we are going to study here; the source of the data does not matter for this. 5.1 Working with a single dataset First, let’s load dplyr and the included starwars dataset. Let’s also take a look at the first 5 lines of the dataset: library(dplyr) data(starwars) head(starwars) ## # A tibble: 6 x 13 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Luke Skywalker 172 77 blond fair blue 19.0 ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112.0 ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red 33.0 ## 4 Darth Vader 202 136 none white yellow 41.9 ## 5 Leia Organa 150 49 brown light brown 19.0 ## 6 Owen Lars 178 120 brown, grey light blue 52.0 ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; data(starwars) loads the example dataset called starwars that is included in the package dplyr. As I said earlier, this is just an example; you could have loaded an external dataset, from a .csv for instance. This does not matter for what comes next. R includes a lot of function for descriptive statistics, such as mean(), sd(), cov(), and many more. What dplyr brings to the table is the possibility to apply these functions to the dataset easily. For example, imagine you want the average height of everyone in the dataset. Using the basic R functions, you could write this: mean(starwars$height) ## [1] NA starwars$height means that the user wants to access the column called height from the dataset starwars. This is then given as an argument to the function mean(). But what if the user wants the average height by species? Before dplyr, a solution to this simple problem would have required more than a single command. Now this is as easy as: starwars %&gt;% group_by(species) %&gt;% summarise(mean(height)) ## # A tibble: 38 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Clawdite 168.0000 ## 6 Droid NA ## 7 Dug 112.0000 ## 8 Ewok 88.0000 ## 9 Geonosian 183.0000 ## 10 Gungan 208.6667 ## # ... with 28 more rows Ok, I know what you’re thinking. What the hell is this weird %&gt;% thing?. That weird thing is called the pipe operator. What it does is taking the left-hand side argument and piping it as the first argument of the function on the right-hand side. Try the following in the command line: 4 %&gt;% sqrt() ## [1] 2 It is equivalent to sqrt(4). Why use that though? You will see in the next examples that using the %&gt;% makes writing and reading code, much, much easier. For example, the previous manipulation I did could be read as “Take the starwars data, give it to the group_by() function and then compute the mean height”. Without the %&gt;%, one would need to write: summarise(group_by(starwars, species), mean(height)) ## # A tibble: 38 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Clawdite 168.0000 ## 6 Droid NA ## 7 Dug 112.0000 ## 8 Ewok 88.0000 ## 9 Geonosian 183.0000 ## 10 Gungan 208.6667 ## # ... with 28 more rows as you can see, it is much more difficult to read. Imagine now that I want average height by species, but only for males. Again, this is very easy using %&gt;%: starwars %&gt;% filter(gender == &quot;male&quot;) %&gt;% group_by(species) %&gt;% summarise(mean(height)) ## # A tibble: 32 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Dug 112.0000 ## 6 Ewok 88.0000 ## 7 Geonosian 183.0000 ## 8 Gungan 208.6667 ## 9 Human NA ## 10 Iktotchi 188.0000 ## # ... with 22 more rows Again, the %&gt;% makes the above lines of code very easy to read. Without it, one would write: summarise(group_by(filter(starwars, gender == &quot;male&quot;), species), mean(height)) ## # A tibble: 32 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79.0000 ## 2 Besalisk 198.0000 ## 3 Cerean 198.0000 ## 4 Chagrian 196.0000 ## 5 Dug 112.0000 ## 6 Ewok 88.0000 ## 7 Geonosian 183.0000 ## 8 Gungan 208.6667 ## 9 Human NA ## 10 Iktotchi 188.0000 ## # ... with 22 more rows I think you agree with me that this is not very readable. Once you’re used to %&gt;%, you won’t go back to not use it. To make things clearer; filter(), group_by() and summarise() are functions that are included in dplyr. %&gt;% is actually a function from magrittr, but this package gets loaded when you load dplyr automatically, so you do not need to worry about it. mean() is a function native to R. Another thing very nice about using dplyr; the result of all these operations are datasets, or tibbles. This means that you can save them in variable, and then work with these as any other datasets. mean_height = starwars %&gt;% group_by(species) %&gt;% summarise(mean(height)) class(mean_height) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; head(mean_height) ## # A tibble: 6 x 2 ## species `mean(height)` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Aleena 79 ## 2 Besalisk 198 ## 3 Cerean 198 ## 4 Chagrian 196 ## 5 Clawdite 168 ## 6 Droid NA You could then write this data to disk using rio::export() for instance. If you need more than the mean of the height, you can keep adding as many functions as needed: summary_table = starwars %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height), var_height = var(height), n_obs = n()) print(summary_table) ## # A tibble: 38 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Aleena 79.0000 NA 1 ## 2 Besalisk 198.0000 NA 1 ## 3 Cerean 198.0000 NA 1 ## 4 Chagrian 196.0000 NA 1 ## 5 Clawdite 168.0000 NA 1 ## 6 Droid NA NA 5 ## 7 Dug 112.0000 NA 1 ## 8 Ewok 88.0000 NA 1 ## 9 Geonosian 183.0000 NA 1 ## 10 Gungan 208.6667 201.3333 3 ## # ... with 28 more rows I did several things there; I’ve added more functions, var() to get the variance and n() (which is a function from dplyr, not base R) to get the number of observations. This is quite useful, because we see that for a lot of species we only have one single individual! Let’s focus on the species for which we have more than 1 individual. Since we save all the previous operations (which produce a tibble) in a variable, we can keep going from there: summary_table2 = summary_table %&gt;% filter(n_obs &gt; 1) print(summary_table2) ## # A tibble: 9 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid NA NA 5 ## 2 Gungan 208.6667 201.3333 3 ## 3 Human NA NA 35 ## 4 Kaminoan 221.0000 128.0000 2 ## 5 Mirialan 168.0000 8.0000 2 ## 6 Twi&#39;lek 179.0000 2.0000 2 ## 7 Wookiee 231.0000 18.0000 2 ## 8 Zabrak 173.0000 8.0000 2 ## 9 &lt;NA&gt; NA NA 5 There’s a lot of NAs; this is because by default, mean() and var() return NA if even one single observation is NA (unlike STATA). mean() and var() have a na.rm option that the user can set to TRUE to get the result by ignoring the NAs: starwars %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 9 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid 140.0000 2704.6667 5 ## 2 Gungan 208.6667 201.3333 3 ## 3 Human 176.6452 157.1699 35 ## 4 Kaminoan 221.0000 128.0000 2 ## 5 Mirialan 168.0000 8.0000 2 ## 6 Twi&#39;lek 179.0000 2.0000 2 ## 7 Wookiee 231.0000 18.0000 2 ## 8 Zabrak 173.0000 8.0000 2 ## 9 &lt;NA&gt; 160.0000 1826.0000 5 In the code above, I have combined the two previous steps to get the result I’m interested in. There’s a line in the final output that says NA for the species. Let’s go back to the raw data and find this line with the function which() (which is a basic R function): na_species &lt;- which(is.na(starwars$species)) starwars[na_species, ] ## # A tibble: 5 x 13 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ric Olié 183 NA brown fair blue NA ## 2 Quarsh Panaka 183 NA black dark brown 62 ## 3 R4-P17 96 NA none silver, red red, blue NA ## 4 Sly Moore 178 48 none pale white NA ## 5 Captain Phasma NA NA unknown unknown unknown NA ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; To test for NA, one uses the function is.na() and then which() returns the index where this condition is TRUE. So what I did above is save the row number where species is NA and then using the [] I slive the original raw data to get the entire line. As you can see, there’s a few of them. An alternative way of doing that, using dplyr would be the following: starwars %&gt;% filter(is.na(species)) ## # A tibble: 5 x 13 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Ric Olié 183 NA brown fair blue NA ## 2 Quarsh Panaka 183 NA black dark brown 62 ## 3 R4-P17 96 NA none silver, red red, blue NA ## 4 Sly Moore 178 48 none pale white NA ## 5 Captain Phasma NA NA unknown unknown unknown NA ## # ... with 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; or if you want to remove these lines: starwars %&gt;% filter(!is.na(species)) ## # A tibble: 82 x 13 ## name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywalker 172 77 blond fair blue ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red ## 4 Darth Vader 202 136 none white yellow ## 5 Leia Organa 150 49 brown light brown ## 6 Owen Lars 178 120 brown, grey light blue ## 7 Beru Whitesun lars 165 75 brown light blue ## 8 R5-D4 97 32 &lt;NA&gt; white, red red ## 9 Biggs Darklighter 183 84 black light brown ## 10 Obi-Wan Kenobi 182 77 auburn, white fair blue-gray ## # ... with 72 more rows, and 7 more variables: birth_year &lt;dbl&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; The ! function negates a predicate function (a predicate function is a function that returns TRUE or FALSE). We can then rerun our analysis from before: starwars %&gt;% filter(!is.na(species)) %&gt;% group_by(species) %&gt;% summarise(ave_height = mean(height, na.rm = TRUE), var_height = var(height, na.rm = TRUE), n_obs = n()) %&gt;% filter(n_obs &gt; 1) ## # A tibble: 8 x 4 ## species ave_height var_height n_obs ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Droid 140.0000 2704.6667 5 ## 2 Gungan 208.6667 201.3333 3 ## 3 Human 176.6452 157.1699 35 ## 4 Kaminoan 221.0000 128.0000 2 ## 5 Mirialan 168.0000 8.0000 2 ## 6 Twi&#39;lek 179.0000 2.0000 2 ## 7 Wookiee 231.0000 18.0000 2 ## 8 Zabrak 173.0000 8.0000 2 dplyr contains a lot of different functions, one of which is mutate(). mutate() allows you to create new columns. For instance, suppose you need a column of the height of the individuals in meters, and not in centimeters: starwars = starwars %&gt;% mutate(height_m = height/100) glimpse(starwars) ## Observations: 87 ## Variables: 14 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, ... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188... ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 8... ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;b... ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;l... ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;,... ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,... ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alder... ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human... ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;Th... ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;,... ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Adva... ## $ height_m &lt;dbl&gt; 1.72, 1.67, 0.96, 2.02, 1.50, 1.78, 1.65, 0.97, 1.8... I have used mutate() to compute the column I need and glimpse() is an alternative to print() that I find very useful because it shows all the columns with as many observations that fit on your screen. We can see the column we created at the very bottom. It might be interesting to reorder the columns; this is possible with select() another dplyr function: starwars = starwars %&gt;% select(name, height, height_m, everything()) glimpse(starwars) ## Observations: 87 ## Variables: 14 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, ... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188... ## $ height_m &lt;dbl&gt; 1.72, 1.67, 0.96, 2.02, 1.50, 1.78, 1.65, 0.97, 1.8... ## $ mass &lt;dbl&gt; 77.0, 75.0, 32.0, 136.0, 49.0, 120.0, 75.0, 32.0, 8... ## $ hair_color &lt;chr&gt; &quot;blond&quot;, NA, NA, &quot;none&quot;, &quot;brown&quot;, &quot;brown, grey&quot;, &quot;b... ## $ skin_color &lt;chr&gt; &quot;fair&quot;, &quot;gold&quot;, &quot;white, blue&quot;, &quot;white&quot;, &quot;light&quot;, &quot;l... ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;brown&quot;, &quot;blue&quot;,... ## $ birth_year &lt;dbl&gt; 19.0, 112.0, 33.0, 41.9, 19.0, 52.0, 47.0, NA, 24.0... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,... ## $ homeworld &lt;chr&gt; &quot;Tatooine&quot;, &quot;Tatooine&quot;, &quot;Naboo&quot;, &quot;Tatooine&quot;, &quot;Alder... ## $ species &lt;chr&gt; &quot;Human&quot;, &quot;Droid&quot;, &quot;Droid&quot;, &quot;Human&quot;, &quot;Human&quot;, &quot;Human... ## $ films &lt;list&gt; [&lt;&quot;Revenge of the Sith&quot;, &quot;Return of the Jedi&quot;, &quot;Th... ## $ vehicles &lt;list&gt; [&lt;&quot;Snowspeeder&quot;, &quot;Imperial Speeder Bike&quot;&gt;, &lt;&gt;, &lt;&gt;,... ## $ starships &lt;list&gt; [&lt;&quot;X-wing&quot;, &quot;Imperial shuttle&quot;&gt;, &lt;&gt;, &lt;&gt;, &quot;TIE Adva... select() allows you to reorder columns by writing the order of the columns you want, and then you can use everything() (another dplyr function) to just tell select() that you want everything else in there. But select() also allows you to only select a subset of columns, if needed: starwars %&gt;% select(name, height, height_m, gender) %&gt;% glimpse() ## Observations: 87 ## Variables: 4 ## $ name &lt;chr&gt; &quot;Luke Skywalker&quot;, &quot;C-3PO&quot;, &quot;R2-D2&quot;, &quot;Darth Vader&quot;, &quot;L... ## $ height &lt;int&gt; 172, 167, 96, 202, 150, 178, 165, 97, 183, 182, 188, ... ## $ height_m &lt;dbl&gt; 1.72, 1.67, 0.96, 2.02, 1.50, 1.78, 1.65, 0.97, 1.83,... ## $ gender &lt;chr&gt; &quot;male&quot;, NA, NA, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, N... The last thing I want to show you are the so-called scoped version of these functions. For example, what if I am only interested in columns that contains text? Is there a way to select them automatically? For this type of tasks, you can use select_if(): starwars %&gt;% select_if(is.character) ## # A tibble: 87 x 7 ## name hair_color skin_color eye_color gender homeworld ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywalker blond fair blue male Tatooine ## 2 C-3PO &lt;NA&gt; gold yellow &lt;NA&gt; Tatooine ## 3 R2-D2 &lt;NA&gt; white, blue red &lt;NA&gt; Naboo ## 4 Darth Vader none white yellow male Tatooine ## 5 Leia Organa brown light brown female Alderaan ## 6 Owen Lars brown, grey light blue male Tatooine ## 7 Beru Whitesun lars brown light blue female Tatooine ## 8 R5-D4 &lt;NA&gt; white, red red &lt;NA&gt; Tatooine ## 9 Biggs Darklighter black light brown male Tatooine ## 10 Obi-Wan Kenobi auburn, white fair blue-gray male Stewjon ## # ... with 77 more rows, and 1 more variables: species &lt;chr&gt; select_if() selects every column that is of type character. There is also select_all() and select_at(), each with they’re own use. I will not go into more detail here. If you are interested, I advise you read dplyr’s help and also the section I wrote in my other book which goes into much more detail. 5.2 Working with a list of datasets Let’s read the list of datasets from the previous chapter: paths = Sys.glob(&quot;datasets/unemployment/*.csv&quot;) all_datasets = import_list(paths) str(all_datasets) ## List of 4 ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of which: Wage-earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of which: Non-wage-earners: int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ Unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ Active population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of which: Wage-earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of which: Non-wage-earners: int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ Unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ Active population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of which: Wage-earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of which: Non-wage-earners: int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ Active population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ Commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ Total employed population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of which: Wage-earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of which: Non-wage-earners: int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ Unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ Active population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ Unemployment rate (in %) : num [1:118] 7.15 5.04 4.84 3.01 4.3 ... For working with lists, another package from the tidyverse is very useful, and that would be purrr. purrr has functions to work with lists, and we are going to focus on two of them, map() and reduce(). map()… maps a function to each element of a list. reduce() is a bit more complicated so we’ll leave that for later. The first thing we are going to do is use a function to clean the names of the datasets. These names are not very easy to work with; there are spaces, and it would be better if the names of the columns would be all lowercase. For this we are going to use the function clean_names() from the janitor package. For a single dataset, I would write this: library(janitor) one_dataset = one_dataset %&gt;% clean_names() and I would get a dataset with column names in lowercase and spaces replaced by _ (and other corrections). How can I apply, or map, this function to each dataset in the list? To do this I need to use purrr::map(): library(purrr) all_datasets = all_datasets %&gt;% map(clean_names) all_datasets %&gt;% glimpse() ## List of 4 ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 223407 17802 1703 844 1431 4094 2146 971 1218 3002 ... ## ..$ of_which_wage_earners : int [1:118] 203535 15993 1535 750 1315 3800 1874 858 1029 2664 ... ## ..$ of_which_non_wage_earners : int [1:118] 19872 1809 168 94 116 294 272 113 189 338 ... ## ..$ unemployed : int [1:118] 19287 1071 114 25 74 261 98 45 66 207 ... ## ..$ active_population : int [1:118] 242694 18873 1817 869 1505 4355 2244 1016 1284 3209 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.95 5.67 6.27 2.88 4.92 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 228423 18166 1767 845 1505 4129 2172 1007 1268 3124 ... ## ..$ of_which_wage_earners : int [1:118] 208238 16366 1606 757 1390 3840 1897 887 1082 2782 ... ## ..$ of_which_non_wage_earners : int [1:118] 20185 1800 161 88 115 289 275 120 186 342 ... ## ..$ unemployed : int [1:118] 19362 1066 122 19 66 287 91 38 61 202 ... ## ..$ active_population : int [1:118] 247785 19232 1889 864 1571 4416 2263 1045 1329 3326 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.81 5.54 6.46 2.2 4.2 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 233130 18310 1780 870 1470 4130 2170 1050 1300 3140 ... ## ..$ of_which_wage_earners : int [1:118] 212530 16430 1620 780 1350 3820 1910 920 1100 2770 ... ## ..$ of_which_non_wage_earners : int [1:118] 20600 1880 160 90 120 310 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18806 988 106 29 73 260 80 41 72 169 ... ## ..$ active_population : int [1:118] 251936 19298 1886 899 1543 4390 2250 1091 1372 3309 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.46 5.12 5.62 3.23 4.73 ... ## $ :&#39;data.frame&#39;: 118 obs. of 7 variables: ## ..$ commune : chr [1:118] &quot;Grand-Duche de Luxembourg&quot; &quot;Canton Capellen&quot; &quot;Dippach&quot; &quot;Garnich&quot; ... ## ..$ total_employed_population : int [1:118] 236100 18380 1790 870 1470 4160 2160 1030 1330 3150 ... ## ..$ of_which_wage_earners : int [1:118] 215430 16500 1640 780 1350 3840 1900 900 1130 2780 ... ## ..$ of_which_non_wage_earners : int [1:118] 20670 1880 150 90 120 320 260 130 200 370 ... ## ..$ unemployed : int [1:118] 18185 975 91 27 66 246 76 35 70 206 ... ## ..$ active_population : int [1:118] 254285 19355 1881 897 1536 4406 2236 1065 1400 3356 ... ## ..$ unemployment_rate_in_percent: num [1:118] 7.15 5.04 4.84 3.01 4.3 ... So now, what if I want to know, for each dataset, which communes have an unemployment rate that is less than, say, 3%? For a single dataset I would do something like this: one_dataset %&gt;% filter(unemployment_rate_in_percent &lt; 3) But for a list of datasets, map() is needed (and as you will see, that is not all that is needed): all_datasets %&gt;% map(~filter(., unemployment_rate_in_percent &lt; 3)) ## [[1]] ## commune total_employed_population of_which_wage_earners ## 1 Garnich 844 750 ## 2 Leudelange 1064 937 ## 3 Bech 526 463 ## of_which_non_wage_earners unemployed active_population ## 1 94 25 869 ## 2 127 32 1096 ## 3 63 16 542 ## unemployment_rate_in_percent ## 1 2.876870 ## 2 2.919708 ## 3 2.952030 ## ## [[2]] ## commune total_employed_population of_which_wage_earners ## 1 Garnich 845 757 ## 2 Leudelange 1102 965 ## 3 Bech 543 476 ## 4 Flaxweiler 879 789 ## of_which_non_wage_earners unemployed active_population ## 1 88 19 864 ## 2 137 34 1136 ## 3 67 15 558 ## 4 90 27 906 ## unemployment_rate_in_percent ## 1 2.199074 ## 2 2.992958 ## 3 2.688172 ## 4 2.980132 ## ## [[3]] ## commune total_employed_population of_which_wage_earners ## 1 Bech 520 450 ## 2 Bous 750 680 ## of_which_non_wage_earners unemployed active_population ## 1 70 14 534 ## 2 70 22 772 ## unemployment_rate_in_percent ## 1 2.621723 ## 2 2.849741 ## ## [[4]] ## commune total_employed_population of_which_wage_earners ## 1 Reckange-sur-Mess 980 850 ## 2 Bech 520 450 ## 3 Betzdorf 1500 1350 ## 4 Flaxweiler 910 820 ## of_which_non_wage_earners unemployed active_population ## 1 130 30 1010 ## 2 70 11 531 ## 3 150 45 1545 ## 4 90 24 934 ## unemployment_rate_in_percent ## 1 2.970297 ## 2 2.071563 ## 3 2.912621 ## 4 2.569593 I know what you’re thinking… what the hell?. Let me explain: map() needs a function to map to each element of the list. all_datasets is the list to which I want to map the function. But what function? filter() is the function I need, so why doesn’t: all_datasets %&gt;% map(filter(unemployment_rate_in_percent &lt; 3)) work? This is a bit complicated, and has to do with what is called environments. If you try to run the code above, you will get this error message: Error in filter(unemployment_rate_in_percent &lt; 3) : object &#39;unemployment_rate_in_percent&#39; not found I won’t go into details, but by writing ~filter(., unemployment_rate_in_percent &lt; 3), which is a formula (~ is the symbol to define formulas, more on this in the later chapters), map() converts it to a function that it can use. If you want to know more about this, you can read it in Advanced R by Hadley Wickham, but it is an advanced topic. "]
]
