# Advanced topics

In this section we are going to learn some advanced concepts that are going to make you into a
full-fledged R programmer. Before this chapter you only used whatever R came with, as well as the
numerous R packages, but now, you will learn to actually build your own functions.

## Control flow

### If-else

Imagine you want a variable to be equal to a certain value if a condition is met. This is a typical
problem that requires the `if ... else ...` construct. For instance:

```{r, cache=TRUE}
a = 4
b = 5
```

If `a > b` then `f` should be equal to 20, else `f` should be equal to 10. Using ```if ... else
...``` you can achieve this like so:

```{r, cache=TRUE}
if (a > b) {
  f = 20
    } else {
  f = 10
}
```

Obviously, here `f = 10`. Another way to achieve this is by using the `ifelse()` function:

```{r, cache=TRUE}
f = ifelse(a > b, 20, 10)
```

This is exactly equivalent as using the longer `if ... else ...` construct.

Nested ```if ... else ...``` constructs can get messy:

```{r, cache=TRUE}
if (10 %% 3 == 0) {
  print("10 is divisible by 3")
  } else if (10 %% 2 == 0) {
    print("10 is divisible by 2")
}
```

10 being obviously divisible by 2 and not 3, it is the second phrase that will be printed. The
`%%` operator is the modulus operator, which gives the rest of the division of 10 by 2.

Remember that if you are working on a dataset and wish to create a new column with values
conditionally on the values of another column, you can use `case_when()`, which is much easier.

### For loops

You are wondering why it took so long for *for loops* to show up. This is because we learned about
`map()` and `reduce()` which solve a lot of problems that for loops were originally intended to
tackle. And actually, you should only use for loops in a very specific situation; whenever you have
a recursive relationship. For all the rest, `map()` and `reduce()` are much easier, and return nice
objects. However, for the sake of completeness, I will present for loops in the section.

For loops make it possible to repeat a set of instructions `i` times. For example, try the following:

```{r, cache=TRUE}
for (i in 1:10){
  print("hello")
}
```

If you want print "hello" using a function from `purrr` you would need to use `rerun()`:

```{r}
rerun(10, "hello")
```

`rerun()` simply runs an expression (which can be arbitrarily complex) `n` times, whereas `map()`
maps a function to a list of inputs, so to achieve the same with `map()`, you need to map the `print()`
function to a vector of characters:

```{r}
map(rep("hello", 10), print)
```

`rep()` is a function that creates a vector by repeating something, in this case the string "hello",
as many times as needed, here 10. The output here is a bit different that before though, because first
you will see "hello" printed 10 times, but `map()` always returns a list, this means that you will also
get a list where each element is the string "hello".

It is also possible to do calculations using for loops. Let's compute the sum of the first 100 integers:

```{r, cache=TRUE}
result = 0
for (i in 1:100){
  result = result + i
}

print(result)
```

`result` is equal to 5050, the expected result. What happened in that loop? First, we defined a
variable called `result` and set it to 0. Then, when the loops starts, `i` equals 1, so we add
`result` to `1`, which is 1. Then, `i` equals 2, and again, we add `result` to `i`. But this time,
`result` equals 1 and `i` equals 2, so now `result` equals 3, and we repeat this until `i`
equals 100.

Contrast this to the `purrr` solution using `reduce()`:

```{r}
result = reduce(seq(1,100), `+`)

print(result)
```

You certainly agree with me that is simpler to understand. You can even see what happens in more
detail using `accumulate`:

```{r}
accumulate(seq(1, 100), `+`)
```

However this does not mean that loops do not have their place. We are going to this in more detail
in the next sections, but first, let's learn about while loops.

### While loops
While loops are very similar to for loops. The instructions inside a while loop are repeat while a
certain condition holds true. Let's consider the sum of the first 100 integers again:

```{r, cache=TRUE}
result = 0
i = 1
while (i<=100){
  result = result + i
  i = i + 1
}

print(result)
```

Here, we first set `result` and `i` to 0. Then, while `i` is inferior, or equal to 100, we add `i`
to `result`. Notice that there is one more line than in the for loop: we need to increment the value
of `i`, if not, `i` would stay equal to 1, and the condition would always be fulfilled, and
the loop would run forever (not really, only until your computer runs out of memory).

In the next section we are going to learn how to write our own functions; this is when we are going
to learn about recursive relationships that for and while loops can solve very well.

## Programming your own functions

As you have seen by now, R includes a very large amount of preprogrammed functions, but also much
more functions are available in packages. However, you will always need to write your own. In this
section we are going to learn how to write our own functions.

### Declaring functions in R

Suppose you want to create the following function: \(f(x) = \dfrac{1}{\sqrt{x}}\).
This is the syntax you would use:

```{r, cache=TRUE}
my_function = function(x){
return(1/sqrt(x))
}
```

While in general, it is a good idea to add comments to your functions to explain what they do, I
would avoid adding comments to functions that do things that are very obvious, such as with this
one. Function names should be of the form: `function_name()`. Always give your function very
explicit names! In mathematics it is standard to give functions just one letter as a name, but I
would advise against doing that in your code. Functions that you write are not special in any way;
this means that R will treat them the same way, and they will work in conjunction with any other
function just as if it was built-in into R. They have one limitation though (which is shared with
R's native function): just like in math, they can only return one value. However, sometimes, you
may need to return more than one value. To be able to do this, you must put your values in a list,
and return the list of values. For example:

```{r, cache=TRUE}
average_and_sd = function(x){
  result = c(mean(x), sd(x))
return(result)
}

average_and_sd(c(1, 3, 8, 9, 10, 12))
```


You can put a lot of instructions inside a function, such as loops. Let's create the function that
returns Fibonacci numbers.

### Fibonacci numbers

The Fibonacci sequence is the following:

$$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...$$

Each subsequent number is composed of the sum of the two preceding ones. In R, it is possible to define a function that returns the $n^{th}$ Fibonacci number:

```{r, cache=TRUE}
Fibo = function(n){
 a = 0
 b = 1
 for (i in 1:n){
  temp = b
  b = a
  a = a + temp
 }
 return(a)
}
```

Inside the loop, we defined a variable called \texttt{temp}. Defining temporary variables is usually very useful inside loops. Let's try to understand what happens inside this loop:

\begin{enumerate}
 \item First, we assign the value 0 to variable \texttt{a} and value 1 to variable \texttt{b}.
 \item We start a loop, that goes from 1 to \texttt{n}.
 \item We assign the value inside of \texttt{b} to a temporary variable, called \texttt{temp}.
 \item \texttt{b} becomes \texttt{a}.
 \item We assign the sum of \texttt{a} and \texttt{temp} to a.
 \item When the loop is finished, we return \texttt{a}.
\end{enumerate}

What happens if we want the $3^{rd}$ Fibonacci number? At \texttt{n = 1} we have first \texttt{a = 0} and \texttt{b = 1}, then \texttt{temp = 1}, \texttt{b = 0} and \texttt{a = 0 + 1}. Then \texttt{n = 2}. Now \texttt{b = 0} and \texttt{temp = 0}. The previous result, \texttt{a = 0 + 1} is now assigned to \texttt{b}, so \texttt{b = 1}. Then, \texttt{a = 1 + 0}. Finally, \texttt{n = 3}. \texttt{temp = 1} (because \texttt{b = 1}), the previous result \texttt{a = 1} is assigned to \texttt{b} and finally, \texttt{a = 1 + 1}. So the third Fibonacci number equals 2. Reading this might be a bit confusing; I strongly advise you to run the algorithm on a sheet of paper, step by step.

The above algorithm is called an iterative algorithm, because it uses a loop to compute the result. Let's look at another way to think about the problem, with a recursive algorithm.

```{r, cache=TRUE}
FiboRecur = function(n){
 if (n == 0 || n == 1){
 return(n)} else {
 return(FiboRecur(n-1) + FiboRecur(n-2))
}
}
```

This algorithm should be easier to understand: if \texttt{n = 0} or \texttt{n = 1} the function should return \texttt{n} (0 or 1). If \texttt{n} is strictly bigger than \texttt{1}, \texttt{FiboRecur} should return the sum of \texttt{FiboRecur(n-1)} and \texttt{FiboRecur(n-2)}. This version of the function is very much the same as the mathematical definition of the Fibonacci sequence. So why not use only recursive algorithms then? Try to run the following:

```{r, cache=TRUE}
system.time(Fibo(30))
```

The result should be printed very fast (the \texttt{system.time()} function returns the time that it took to execute \texttt{Fibo(30)}). Let's try with the recursive version:

```{r, cache=TRUE}
system.time(FiboRecur(30))
```

It takes much longer to execute! Recursive algorithms are very CPU demanding, so if speed is critical, it's best to avoid recursive algorithms. Also, in \texttt{FiboRecur} try to remove this: \texttt{if (n == 0 || n == 1)} and try to run \texttt{FiboRecur(5)} for example and see what happens. You should get an error: this is because for recursive algorithms you need a stopping condition, or else, it would run forever. This is not the case for iterative algorithms, because the stopping condition is the last step of the loop.

\section*{Exercises}

\emph{Write the answers to this exercise inside a file called yourname\_functions.R and send it to me: \texttt{brodrigues```unistra.fr}. Use comments to explain what you do!}\newline

\emph{Exercise 1} In this exercise, you will write a function to compute the sum of the n first integers. Combine the algorithm we saw in section \ref{whileloops} and what you learned about functions in this section.


%MySum = function(n){
%result = 0
%i = 1
%while (i<=n){
%result = result + i
%i = i + 1
%}
%return(result)
%}


\emph{Exercise 2} Write a function called \texttt{MyFactorial} that computes the factorial of a number \texttt{n}. Do it iteratively and recursively.

%MyFactorialIter = function(n){
%result = 1
%for(i in 1:n){
%result = result * i
%i = i + 1
%}
%return(result)
%}


%MyFactorialRecur = function(n){
%if(n == 0 || n == 1){
%result = 1 } else {
%return(n * MyFactorialRecur(n-1))
%}
%}

\emph{Exercise 3} In this exercise, we will find the eigenvalues of the following matrix:

$$A = \left(
\begin{array}{ccc}
3 & 1\\
1 & 3\\
\end{array}
\right)$$

For this exercise, we will first think about the problem at hand, and try to simplify it as much as possible before writing any code.

Remember that if A is full column rank, there will be 2 eigenvalues. Also, remember that the sum of the eigenvalues equals the trace of the matrix and that the product of the eigenvalues equals the determinant of the matrix. This gives you a system of 2 equations. Replace one equation into the other. What do you get? What is it that you finally have to do? Program a function to solve your problem now.

% To solve the problem, we need to solve a quadratic function. Below is a
% function that returns the roots of a quadratic function

% A = matrix(c(3, 1, 1, 3), nrow = 2, ncol = 2, byrow = TRUE)

% QuadRoot = function(a, b, c){
% fonction that return the root of a quadratic function
% very basic, doesn't cover the case where delta < 0
%  delta = b**2 - 4 * a * c
%  x1 = (-b + sqrt(delta)) / (2 * a)
%  x2 = (-b - sqrt(delta)) / (2 * a)
%  return(c(x1, x2))
%}

% QuadRoot(1, -sum(diag(A)), det(A))





Before merging these datasets together, we would need them to have a `year` column indicating the
year. It would also be helpful if gave names to these datasets. For this task, we can use
`purrr::set_names()`:

```{r}
all_datasets = set_names(all_datasets, as.character(seq(2013, 2016)))
```

Let's take a look at the list now:

```{r}
str(all_datasets)
```

As you can see, each `data.frame` object contained in the list has been renamed. You can thus
access them with the `$` operator:

```{r, echo=FALSE}
knitr::include_graphics("pics/all_datasets_names.png")
```

## Generating Pdf or Word reports with R

## Scraping the internet

## Writing your own package

## Random tips and tricks

### Creating a log file


## Exercises

### Exercise 1 {-}

* Create the following vector:

\[a = (1,6,7,8,8,9,2)\]

Using a for loop and a while loop, compute the sum of its elements. To avoid issues, use `i`
as the counter inside the for loop, and `j` as the counter for the while loop.

```{r, include=FALSE}
result = 0
  for(i in 1:length(a)){
    result = result + a[i]
}

result = 0
  while (i<=length(a)){
    result = result + a[i]
    i = i + 1
}
```

* How would you achieve that with a functional (a function that takes a function as an argument)?

### Exercise 2 {-}

* Let's use a loop to get the matrix product of a matrix A and B. Follow these steps to create the loop:

1) Create matrix A:

\[A = \left(
  \begin{array}{ccc}
   9 & 4 & 12 \\
   5 & 0 & 7 \\
   2 & 6 & 8 \\
   9 & 2 & 9
  \end{array} \right)
\]

2) Create matrix B:

\[B = \left(
\begin{array}{cccc}
 5 & 4 & 2 & 5 \\
 2 & 7 & 2 & 1 \\
 8 & 3 & 2 & 6 \\
\end{array} \right)
\]

3) Create a matrix C, with dimension 4x4 that will hold the result. Use this command: `C = matrix(rep(0,16), nrow = 4)}

4) Using a for loop, loop over the rows of A first: `for(i in 1:nrow(A))}

5) Inside this loop, loop over the columns of B: `for(j in 1:ncol(B))}

6) Again, inside this loop, loop over the rows of B: `for(k in 1:nrow(B))}

7) Inside this last loop, compute the result and save it inside C: `C[i,j] = C[i,j] + A[i,k] * B[k,j]}

```{r, include=FALSE}
A = matrix( c(9, 4, 12, 5, 0, 7, 2, 6, 8, 9, 2, 9), nrow = 4, byrow = TRUE)

B = matrix( c(5, 4, 2, 5, 2, 7, 2, 1, 8, 3, 2, 6), nrow = 3, byrow = TRUE)

C = matrix(rep(0,16), nrow = 4)

for(i in 1:nrow(A)){
  for(j in 1:ncol(B)){
    for(k in 1:nrow(B)){
      C[i,j] = C[i,j] + A[i,k] * B[k,j]
    }
  }
}
```

* R has a built-in function to compute the dot product of 2 matrices. Which is it?

### Exercise 3 {-}

* Fizz Buzz: Print integers from 1 to 100. If a number is divisible by 3, print the word `Fizz` if
it's divisible by 5, print `Buzz`. Use a for loop and if statements.

### Exercise 4 {-}

* Fizz Buzz 2: Same as above, but now add this third condition: if a number is both divisible by 3 and 5, print `"FizzBuzz"`.

```{r}
for (i in 1:100){
if (i %% 15 == 0) {
  print("FizzBuzz")
} else if (i %% 3 == 0) {
  print("Fizz")
} else if (i %% 5 == 0) {
  print("Buzz")
} else {
  print(i)
}
}
```
