# Advanced topics

In this section we are going to learn some advanced concepts that are going to make you into a
full-fledged R programmer. Before this chapter you only used whatever R came with, as well as the
numerous R packages, but now, you will learn to actually build your own functions.

## Control flow

### If-else

Imagine you want a variable to be equal to a certain value if a condition is met. This is a typical
problem that requires the `if ... else ...` construct. For instance:

```{r, cache=TRUE}
a = 4
b = 5
```

If `a > b` then `f` should be equal to 20, else `f` should be equal to 10. Using ```if ... else
...``` you can achieve this like so:

```{r, cache=TRUE}
if (a > b) {
  f = 20
    } else {
  f = 10
}
```

Obviously, here `f = 10`. Another way to achieve this is by using the `ifelse()` function:

```{r, cache=TRUE}
f = ifelse(a > b, 20, 10)
```

This is exactly equivalent as using the longer `if ... else ...` construct.

Nested ```if ... else ...``` constructs can get messy:

```{r, cache=TRUE}
if (10 %% 3 == 0) {
  print("10 is divisible by 3")
  } else if (10 %% 2 == 0) {
    print("10 is divisible by 2")
}
```

10 being obviously divisible by 2 and not 3, it is the second phrase that will be printed. The
`%%` operator is the modulus operator, which gives the rest of the division of 10 by 2.

Remember that if you are working on a dataset and wish to create a new column with values
conditionally on the values of another column, you can use `case_when()`, which is much easier.

### For loops

You are wondering why it took so long for *for loops* to show up. This is because we learned about
`map()` and `reduce()` which solve a lot of problems that for loops were originally intended to
tackle. And actually, you should only use for loops in a very specific situation; whenever you have
a recursive relationship. For all the rest, `map()` and `reduce()` are much easier, and return nice
objects. However, for the sake of completeness, I will present for loops in the section.

For loops make it possible to repeat a set of instructions `i` times. For example, try the following:

```{r, cache=TRUE}
for (i in 1:10){
  print("hello")
}
```

If you want print "hello" using a function from `purrr` you would need to use `rerun()`:

```{r}
rerun(10, "hello")
```

`rerun()` simply runs an expression (which can be arbitrarily complex) `n` times, whereas `map()`
maps a function to a list of inputs.

It is also possible to do calculations using for loops. Let's compute the sum of the first 100 integers:

```{r, cache=TRUE}
result = 0
for (i in 1:100){
  result = result + i
}

print(result)
```

`result` is equal to 5050, the expected result. What happened in that loop? First, we defined a
variable called `result` and set it to 0. Then, when the loops starts, `i` equals 1, so we add
`result` to `1`, which is 1. Then, `i` equals 2, and again, we add `result` to `i`. But this time,
`result` equals 1 and `i` equals 2, so now `result` equals 3, and we repeat this until `i`
equals 100.

Contrast this to the `purrr` solution using `reduce()`:

```{r}
result = reduce(seq(1,100), `+`)

print(result)
```

You certainly agree with me that is simpler to understand. You can even see what happens in more
detail using `accumulate`:

```{r}
accumulate(seq(1, 100), `+`)
```

However this does not mean that loops do not have their place. We are going to this in more detail
in the next sections.

### Recursive relationships


### While loops
While loops are very similar to for loops. The instructions inside a while loop are repeat while a certain condition holds true. Let's consider the sum of the first 100 integers again:

```{r, cache=TRUE}
result = 0
i = 1
while (i<=100){
  result = result + i
  i = i + 1
}

print(result)
```

Here, we first set `result} and `i} to 0. Then, while `i} is inferior, or equal to 100, we add `i} to `result}. Notice that there is a line more than in the for loop: we need to increment the value of `i}, if not, `i} would stay equal to 1, and the condition would always be fulfilled, and the program would run forever (not really, only until your computer runs out of memory).

\section*{Exercises}

\emph{Write the answers to this exercise inside a file called yourname\_flow.R and send it to me: `brodrigues```unistra.fr}. Use comments to explain what you do!}\newline

\emph{Exercise 1} Create the following vector:

$$a = (1,6,7,8,8,9,2)$$

Using a for loop and a while loop, compute the sum of its elements. To avoid issues, use `i} as the counter inside the for loop, and `j} as the counter for the while loop.

%result = 0
%for(i in 1:length(a)){
%result = result + a[i]
%}

%result = 0
%while (i<=length(a)){
%result = result + a[i]
%i = i + 1
%}

\emph{Exercise 2} Let's use a loop to get the matrix product of a matrix A and B. Follow these steps to create the loop:

\begin{enumerate}
 \item Create matrix A:

 $$A = \left(
\begin{array}{ccc}
 9 & 4 & 12 \\
 5 & 0 & 7 \\
 2 & 6 & 8 \\
 9 & 2 & 9
\end{array} \right)
$$

\item Create matrix B:

$$B = \left(
\begin{array}{cccc}
 5 & 4 & 2 & 5 \\
 2 & 7 & 2 & 1 \\
 8 & 3 & 2 & 6 \\
\end{array} \right)
$$

\item Create a matrix C, with dimension 4x4 that will hold the result. Use this command: `C = matrix(rep(0,16), nrow = 4)}

\item Using a for loop, loop over the rows of A first: `for(i in 1:nrow(A))}

\item Inside this loop, loop over the columns of B: `for(j in 1:ncol(B))}

\item Again, inside this loop, loop over the rows of B: `for(k in 1:nrow(B))}

\item Inside this last loop, compute the result and save it inside C: `C[i,j] = C[i,j] + A[i,k] * B[k,j]}

\end{enumerate}


%A = matrix( c(9, 4, 12, 5, 0, 7, 2, 6, 8, 9, 2, 9), nrow = 4, byrow = TRUE)

%B = matrix( c(5, 4, 2, 5, 2, 7, 2, 1, 8, 3, 2, 6), nrow = 3, byrow = TRUE)

%C = matrix(rep(0,16), nrow = 4)

%for(i in 1:nrow(A)){
%  for(j in 1:ncol(B)){
%    for(k in 1:nrow(B)){
%      C[i,j] = C[i,j] + A[i,k] * B[k,j]
%    }
%  }
%}

\emph{Exercise 3} Fizz Buzz: Print integers from 1 to 100. If a number is divisible by 3, print the word `Fizz} if it's divisible by 5, print `Buzz}. Use a for loop and if statements.

%for (i in 1:100){
%if (i %% 15 == 0) {
%  print("FizzBuzz")
%} else if (i %% 3 == 0) {
%  print("Fizz")
%} else if (i %% 5 == 0) {
%  print("Buzz")
%} else {
%  print(i)
%}
%}

\emph{Exercise 4} Fizz Buzz 2: Same as above, but now add this third condition: if a number is both divisible by 3 and 5, print `"FizzBuzz"}.

## Programming your own functions

Before merging these datasets together, we would need them to have a `year` column indicating the
year. It would also be helpful if gave names to these datasets. For this task, we can use
`purrr::set_names()`:

```{r}
all_datasets = set_names(all_datasets, as.character(seq(2013, 2016)))
```

Let's take a look at the list now:

```{r}
str(all_datasets)
```

As you can see, each `data.frame` object contained in the list has been renamed. You can thus
access them with the `$` operator:

```{r, echo=FALSE}
knitr::include_graphics("pics/all_datasets_names.png")
```

## Generating Pdf or Word reports with R

## Scraping the internet

## Writing your own package

## Random tips and tricks

### Creating a log file
